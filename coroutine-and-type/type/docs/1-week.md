# 타입으로 유연하게 다형성으로 견고하게

## 타입 검사 훑어보기

### 타입검사가 무엇이고, 왜 필요한지

타입검사는 버그로 인한 피해를 최소화 하기 위해서 존재한다.  
타입은 프로그램에 존재하는 값(value)을 그 능력에 따라 분류한 것이다.  
값이란 변수(variable)에 저장되거나 함수(function)에서 반환될 수 있는 1, true, "abc" 같은 것들을 말한다.

타입은 값의 유형에 따라 타입을 묶을 수 있다.

만약 타입 오류로 인한 버그를 찾는데 오랜 시간동안 실행해야 찾는 상황이 발생된다면, 프로그램이 자동으로 판단해 주는 프로그램인 타입 검사기(type checker)를 사용하는 것이 좋다.

타입 검사기의 가장 중요한 성질은, 흔히 타입 안정성(type safety) 라고 부른다.

### 정적 타입 언어

타입검사기 제작은 언어를 만든 사람의 몫이다. 언어를 설계할 때 타입 검사기도 같이 만든다.

정적 타입의 언어

- 자바, C, C++, C#, 타입스크립트, 고(Go), 러스트, 스칼라, 하스켈, 오캐멀

정적이라는 것은 `프로그램을 실행하기 전에` 를 뜻한다.

타입 검사기를 제공하지 않는 언어

- 자바스크립트, 파이썬, 루비(Ruby), 리스프(LISP)

### 타입 검사기의 원리

작은 부품의 정보를 알아내고, 그 작은 부품들이 더 큰부품을 구성할 때 각각의 작은 부품이 올바르게 사용되었는지 확인하는 것을 반복한다.

```printInt(5 + 7) ```

printInt 함수의 이름으로 더이상 쪼갤 수 없는 기본 부품이다.
한편 5+7은 또 다시 부품 두 개로 구성된다.

### 리터럴

정수 리터럴은 더는 쪼개지지 않는 기본 부품이니 타입만 찾으면 된다.

### 삼항연산자

```
true ? 1:2
```

`true ? 1:2` 구문을 보면, ? 는 boolean 값을 나타내고, 1 : 2는 각각 비교 했을 때 boolean 값이 나오므로 boolean ? boolean 이라 참이라 여길 수 있다.

- 개인적으로는 kotlin에서 `?.let` 같은 함수를 작성할 때 타입이 서로 맞지 않는 형태로 작성하는 경우가 더러 있었다.
- 이런 부분들도 타입 검사기 동작 원리를 생각해보면 재미 있는 것 같다.

### 함수

어떤 함수를 사용한다는 것은 그 함수를 호출한다는 말이다. 함수를 호출하는 부품은 `f(a)` 형태다. f는 함수 이름, a는 함수에 넘길 인자의 값을 결정하는 부품이다.

`Boolean isPositive(Int num)` 이라는 함수를 살펴보면 Boolean을 리턴하며, 매개변수로 Int 값을 받는 것을 알 수 있다.

이런 형태로 함수내 반환값, 입력값등의 타입을 명시적으로 지정함으로써 코드를 작성하는 사람들에게 타입을 잘못 입력했다는 것을 안내할 수 있다.

### 프로그램 성능

정적 타입 언어의 두 번째 장점은 뛰어난 성능  
프로그램의 실행 시간이 짧다  
같은 프로그램을 작성해도 정적 타입 언어를 사용한 쪽의 실행이 더 금방 끝난다.  
이 부분도 타입 검사기 덕분이다.
성능을 가장 중요한 목표로 두고 만든 언어인 C, C++, 러스트가 모두 정적 타입 언어인 것은 결코 우연이 아니다.

### 타입 추론

다양한 장점에도 불구하고 정적 타입 언어에는 불편한 점도 있다. 그중 하나가 타입 표시다.
타입 검사기가 변수나 함수의 타입을 알 수 있도록 개발자가 타입 표시를 제공해야 한다.
타입 표시가 없는 동적 타입언어와 비교하면 확실히 불편하다.

이런 불편함을 해소하려고 여러 언어들이 기능을 제공해주는 것이 타입 추론(type inference)이다.

타입 추론은 생략된 타입 표시를 복구할 뿐이다. 타입 표시를 생략하는 거지, 타입 검사를 생략하는 게 아니다. 즉, 타입 검사 중에 생략된 매개변수 타입에 해당하는 타입을 찾을 수 있어야 한다.

### 정적 타입 언어의 장단점

장점

- 프로그램이 크면 버그가 많으니 모두 찾기 어려움.
- 만드는 시간도 오래걸리고 긴 코드를 이해하기도 어려움.
- 타입의 오류를 모두 자동으로 찾고, 코드 편집기의 능력을 최대로 끌어내고, 코드의 가독성이 우월한 점

단점

- 작은 크기의 프로그램을 만들 때 정적 타입 언어의 장점이 큰 이점이 없다.
- 코드 양이 적고 버그도 금방 찾을 수 있으며, 코드 이해도 쉽다.

### 다형성

다형성(polymorphism)은 타입 검사기의 오판을 줄이는 안전한 기능의 대부분을 차지하는 개념이다.
다형성은 크게 서브타입에 의한 다형성, 매개변수에 의한 다형성, 오버로딩에 의안 다형성으로 나눌 수 있다.

1. 서브타입에 의한 다형성 (Subtype Polymorphism)
   서브타입 다형성은 상속을 통해 구현되며, 부모 클래스 타입으로 자식 클래스 객체를 참조할 수 있습니다.

```kotlin
open class Animal {
    open fun sound() {
        println("Some sound")
    }
}

class Dog : Animal() {
    override fun sound() {
        println("Bark")
    }
}

class Cat : Animal() {
    override fun sound() {
        println("Meow")
    }
}

fun main() {
    val myDog: Animal = Dog()
    val myCat: Animal = Cat()

    myDog.sound() // Bark
    myCat.sound() // Meow
}

```

2. 매개변수에 의한 다형성 (Parametric Polymorphism)
   매개변수 다형성은 주로 제네릭을 통해 구현되며, 타입 매개변수를 사용하여 다양한 타입에 대해 작동하는 함수나 클래스를 만듭니다.

``` kotlin
class Box<T>(t: T) {
    var value = t
}

fun main() {
    val intBox = Box(10)
    val stringBox = Box("Hello World")

    println(intBox.value) // 10
    println(stringBox.value) // Hello World
}

```

3. 오버로딩에 의한 다형성 (Overloading Polymorphism)
   오버로딩 다형성은 같은 이름의 함수나 생성자가 다른 매개변수를 가질 수 있게 합니다.

``` kotlin
fun add(a: Int, b: Int): Int {
    return a + b
}

fun add(a: Double, b: Double): Double {
    return a + b
}

fun add(a: String, b: String): String {
    return a + b
}

fun main() {
    println(add(5, 3)) // 8
    println(add(5.5, 3.3)) // 8.8
    println(add("Hello, ", "World")) // Hello, World
}

```
