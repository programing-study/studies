# 두 다형성의 만남

## 제네릭 클래스와 상속

전통적으로는 객체 지향 언어가 서브타입에 의한 다형성을, 함수형 언어가 매개변수에 의한 다형성을 지원했다. 하지만, 최근에는 한 언어가 두 종류의 다형성을 모두 제공하는 경우가 흔하다.

### 제네릭 클래스를 상속과 함께 사용하는 방법

```
class ArrayList<T> {
    T get(Int idx) { ... }
    ...
}

class LinkedList<T> {
    T get(Int idx) { ... }
    ...
}
```

같은 일을 하는 타입을 각각 ArrayList와 LinkedList로 나눌 경우

각 List를 매개변수로 하는 메서드에서는 저 두가지 타입을 다 받아들일 수 없다.  
각각 만들어놔야 한다.

이런 부분을 해소할 수 있는 방법은 두 클래스가 추상 클래스를 상속 받도록 구현하는 것이다.

```
abstract class List<T> {
   T get(int idx) { ... }
   ... 
}
```

```
class ArrayList<T> extends List<T>{
    T get(Int idx) { ... }
    ...
}

class LinkedList<T> extens List<T> {
    T get(Int idx) { ... }
    ...
}
```

이렇게 구성하면 T는 ArrayList<T>와 LinkedList<T> 는 List<T>의 서브타입이 된다.

- A는 B이다로 대입해보면, 정수로 구성된 연결 리스트는 정수로 구성된 리스트다 는 올바르다.

> BitVector  
> BitVector는 컴퓨터 공학에서 데이터를 효율적으로 표현하고 조작하기 위해 사용되는 데이터 구조입니다. 이 구조는 비트(bit)의 배열로, 각 비트는 0 또는 1의 값을 가질 수 있습니다. BitVector는
> 비트 배열이라고도 불리며, 다양한 응용 프로그램에서 사용됩니다. 예를 들어, 데이터의 집합을 표현하거나, 빠른 검색과 데이터 필터링, 압축, 스트림 처리 등에 활용됩니다.
> BitVector의 주요 장점은 메모리 사용량이 적고, 비트 단위 연산을 사용하여 데이터를 효율적으로 처리할 수 있다는 점입니다. 예를 들어, 두 BitVector의 비트별 AND, OR, XOR 연산을 통해
> 집합의 교집합, 합집합, 대칭 차집합 등을 계산할 수 있습니다. 또한, 특정 비트를 빠르게 설정하거나 검사하는 등의 작업도 간단하게 수행할 수 있습니다.
> 비트 벡터는 네트워크 프로토콜, 암호학, 데이터베이스 인덱싱, 압축 알고리즘 등 다양한 분야에서 널리 사용됩니다. 특히, 대용량 데이터를 다룰 때 공간 효율성과 처리 속도 면에서 매우 유용합니다.

### 타입 인자가 특정 타입일 때만 상속하는 경우

타입 검사기가 서브타입 관계를 파악하려면 각 클래스가 무엇을 상속하는지 정확히 알아야 한다.  
이러한 이유로 그냥 extends List라고 쓸 수 없는 이유가 된다.

> `C<T> extends D` 는, `C<A>` 는 '타입 D에 등장하는 모든 T를 A로 바꿔서 만든 타입' 의 서브 타입이다."

## 타입 매개변수 제한

```
class Person {
    Int age;
    ...
}

class Student extends Person { ... }
```

```
Person elder(Person p, Person q) {
    return (p.age >= q.age) ? p : q;
}
```

위 코드를 이용해서 Person은 elder 함수를 사용할 수 있지만, Person을 상속받은 Student는 통과할 수 없다.

elder가 반환값을 Student 타입의 변수 s에 대입하는 데서 발생한다. elder의 결과 타입은 Person이며 Person은 Student의 서브타입이 아니다.  
따라서, 타입검사기는 `Student가 필요한데 Person인 elder(s1, s3) 가 발견됨` 이라면서 우리의 코드를 거부한다.
따라서 이러한 상황을 해결하려면 타입 매개변수 제한이 필요하다.

elder를 타입 매개변수 T를 가진 제네릭 함수로 정의하되 T에 제한을 거는 것이다. T가 모든 타입이 아니라 Person의 서브타입만 나타낸다는 사실을 타입 검사기에 알려줘야 한다.

```
T elder<T <: Person>(T p, T q) {
    return (p.age >= q.age) ? p : q;
}
```

T <: Person은 타입 매개변수의 T의 상한 (upper bound)로 지정한 것으로, 직관적으로는 `T가 최대 Person 타입까지 커질 수 있다` 라는 의미이다.
또한, `T가 Person의 서브타입이다` 라고도 볼 수 있다.

이전까지 제네릭 함수가 아무 타입이나 타입 인자로 받을 수 있었던 것과 달리, 타입 매개변수 제한을 사용한 제네릭 함수를 사용할 때는  
정의된 상한을 타입 인자가 따라야 한다. 따라서 `elder<Int>` 처럼 Person의 서브타입이 아닌 타입을 타입 인자로 사용한 코드는 타입 검사를 통과하지 못하는데, 이것은 합리적인 판단이다.

## 가변성

가변성(variance)은 여기에 더해 제네릭 타입 사이의 서브타입 관계를 추가로 정의하는 기능이다.

상속은 List와 ArrayList처럼 서로 다른 제네릭 타입 사이의 서브타입 관계를 만든다. 반면 가변성은 하나의 제네릭 타입에서 타입 인자만 다르게 하여 얻은 타입들 사이의 서브타입 관계를 만든다.

```
abstract class List1<T> {
    T get(Int idx);
}
```

```
List1<Student> students = ...;
List1<Person> people = students;  // 가능

Person p = people.get(...);
p.age ...
```

이런 경우 List<Student>가 List1<Person>의 서브 타입이다.

```
abstract class List2<T> {
    T get(Int idx);
    Void add(T t);
}

List2<Student> students = ...;
List2<Person> people = students; // 문제 없음

people.add(new Person()); // 새로운 Person이 추가 됨 

Student s = people.get(...); // <-- people 안에 위에서 추가한 Person이 들어 있는 경우 형변환에 실패 할 수 있다.
s.gpa ...
```

타입 검사기 입장에서는 students의 타입은 변함 없이 List2<Student>다.

위와 같이 `students에 person이 섞여 있는 경우 students.get(..) 이후 person에 없는 값을 접근하려 할 떄 문제가 된다.`
따라서 List2<Student>가 List2<Person>의 서브타입이 아니다.

List1은 원소 읽기만 허용하고, List2는 그에 더해 원소 추가도 허용한 부분부터 이런 차이가 발생한다.

정리를 해보면, `어떤 제네릭 타입은 타입 인자의 서브타입 관계를 보존하지만, 어떤 제네릭 타입은 그렇지 않다`라는 것이다.  
그러므로 제네릭 타입과 타입 인자 사이의 관계를 분류할 수 있다. 이 분류를 가변성이라고 부른다.  
다시 말해 가변성이란 제네릭 타입과 타입 인자 사이의 관계를 뜻한다.

첫 번째 가변성은 제네릭 타입이 타입 인자의 서브타입 관계를 보존하는 것이다.  
List1이 여기에 해당한다. `B가 A의 서브타입일 때, List1<B>가 List1<A>의 서브타입이다.`  
제네릭 타입 인자와 `함께 변한다`는 뜻을 담아, 이런 가변성을 공변(covariance)이라고 부른다.

두 번째 가변성은 제네릭 타입이 타입 인자의 서브타입 관계를 무시하는 것이다.  
B가 A의 서브타입이더라도 `List2<B>`와 `List2<A>` 사이에 아무런 관계가 없다. 그냥 서로 다른 타입인 것이다.  
따라서 타입 인자가 서브타입으로 변해도 제네릭 타입은 서브타입으로 `안 변한다`는 뜻으로서, 이런 가변성을 불변(invariance) 라고 부른다.

세 번째 가변성은 제네릭 타입이 타입 인자의 서브타입 관계를 뒤집는 것이다.  
결과 타입을 X로 고정할 때 B가 A의 서브타입이면 B => C는 A => C의 슈퍼타입이다.  
타입 인자가 A에서 서브타입인 B로 변할 때 A => C는 타입인자와는 반대 방향으로 움직여 슈퍼타입인 B => C로 변한다고도 할 수 있다.   
그러므로 제네릭 타입이 타입 인자와 `반대로 변한다`는 의미를 담아 이런
가변성을 반변(contravariance)이라고 부른다.

> 제네릭 타입의 이름은 G, 타입 매개변수의 이름은 T라고 하자. 우리가 궁금한 것은 G의 가변성을 반단하는 방법이다.  
> 결론부터 말하자면, G가 T를 출력에만 사용하면 공변, 입력에만 사용하면 반변, 출력과 입력 모두에 사용하면 불변이다.

| G에 해당하는 타입 | T를 출력에 사용 | T를 입력에 사용 | 가변성 |
|------------|-----------|-----------|-----|
| List<T>    | O         | X         | 공변  |
| List2<T>   | O         | O         | 불변  |
| Int => T   | O         | X         | 공변  |
| T => Int   | X         | O         | 반변  |
