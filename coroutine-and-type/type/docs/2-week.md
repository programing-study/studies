# 서브타입에 의한 다형성

## 서브타입

서브타입은 "A는 B이다" 라는 타입 사이의 관계다. "A는 B"라는 설명이 올바르면 A는 B의 서브타입이다.  
(서브타입과 반대되는 의미는 슈퍼타입(supertype)이다.)

A가 B의 서브타입일 때 A타입의 부품을 B타입의 부품으로 간주할 수 있게 하는 기능이 서브타입에 의한 다형성이다.

## 이름에 의한 서브타입

## 구조에 의한 서브타입

클래스 A에 필드 f,g가 정의되어 있고, 클래스 B에는 필드 f가 정의되어 있다고 하자.   
그러면 A 의 객체는 `필드 f,g를 가진 객체` 이고 B타입의 `객체는 필드 f를 가진 객체`다.  
따라서 A가 B의 서브타입인지 확인하려면 `필드 f,g를 가진 객체는 필드 f를 가진 객체다` 라는 설명이 올바른지 보면 된다.

구조에 의한 서브타입을 더욱 잘 활용하려면 한 가지 개념을 더 아는게 좋다. 바로 구조를 드러내는 타입(structual type)이다.

이름만 보여주는 방식의 타입을 이름을 드려내는 타입(nominal type)이라고 부른다.

구조를 드러내는 타입은 객체가 가지는 필드와 메서드를 그냥 나열 한 것이다.
예를 들면 {String email;}은 구조를 드러낸 타입이다.

```scala
def useResource(resource: { val resourceID: Int; def getResourceInfo(): String }): Unit = {
  println(s"Using resource with ID: ${resource.resourceID}")
  println(s"Resource info: ${resource.getResourceInfo()}")
}

// 사용 예제
class Resource {
  val resourceID: Int = 101
  def getResourceInfo(): String = "This is a resource"
}

val myResource = new Resource()
useResource(myResource)

```

```typescript
interface Resource {
    resourceID: number;

    getResourceInfo(): string;
}

function useResource(resource: Resource) {
    console.log(`Using resource with ID: ${resource.resourceID}`);
    console.log(`Resource info: ${resource.getResourceInfo()}`);
}

// 사용 예제
const myResource = {
    resourceID: 101,
    getResourceInfo: () => "This is a resource"
};

useResource(myResource);

```

### 두 언어의 비교

* Scala: 구조적 타입을 통해 런타임에 리플렉션을 사용하여 객체가 특정 필드와 메소드를 가지고 있는지 확인합니다.
* TypeScript: 컴파일 타임에 인터페이스를 통해 객체가 특정 필드와 메소드를 만족하는지 확인합니다.

구조를 드러내는 타입을 사용하면 클래스를 정의하지 않고도 sendEmail이 항상 잘 작동하도록 고칠 수 있다.  
구조를 드러내는 타입을 사용할 때도 "A가 B의 서브타입이다" 라는 규칙이 잘 적용된다.

### 추상 메서드

메서드를 정의하지는 않되 '이 클래스를 상속하려면 특정 메서드를 반드시 정의해야 한다'는 사실을 표현한 것이 추상 메서드의 용도다.  
추상 메서드는 몸통 없이 이름, 매개변수 타입, 결과 타입만 작성된 메서드다( 매개변수 이름도 같이 적혀 있기는 하지만 별로 중요한 역할을 하지 않는다)    
이 셋을 묶어 메서드의 시그니처(signature)라고 부른다. 시그니처에 서명 특징이라는 뜻이 있듯이 메서드 시그니처는 타입 검사를 할 때 메서드의 서명 같은 존재로서 메서드의 특징을 알려 준다.

따라서, 추상 메서드는 일반적인 메서드와는 다르게 몸통이 없고 시그니처만 가진다.

### 추상 클래스

추상 클래스를 만드는 목적은 언제나 메서드의 존재에 관한 정보를 타입 검사기에 제공하려는 것이다.  
그 자체로 객체를 만드려는 게 아니다. 그렇기에 추상 클래스가 객체를 직접 만들지 못하는게 합리적이며, 이 제약사항이 불편할 일도 없다.  
(추상 클래스에 변수를 가지는 것은 잘못된 것인가?)

#### 추상 클래스의 주된 용도

추상 클래스의 주된 용도는 부분적으로 구현된 클래스를 제공하여, 이를 상속받는 하위 클래스에서 나머지 구현을 완성하도록 하는 것입니다. 이는 메서드의 시그니처(이름, 매개변수 타입, 반환 타입 등)를 정의함으로써
타입 검사기에 메서드의 존재를 알리는 것을 포함합니다. 추상 메서드는 구현이 없기 때문에, 이러한 메서드들의 집합은 하위 클래스가 구현해야 할 "계약"의 일부를 형성합니다.

#### 추상 클래스에 변수(필드) 적용

추상 클래스에 변수(필드)를 포함시키는 것은 타입 검사기에게 불필요한 정보라기보다, 추상 클래스를 사용하는 전체 설계의 일부분을 나타냅니다. 이 변수들은 추상 클래스와 그 하위 클래스가 공유할 상태를 정의할 수
있으며, 이 상태는 구체적인 구현과 함께 클래스의 행동을 정의하는 데 중요할 수 있습니다.

예를 들어, 모든 동물이 이름을 가지고 있다고 가정할 때, Animal이라는 추상 클래스에 name 필드를 포함시킬 수 있습니다. 이 필드는 Animal 클래스를 상속받는 모든 하위 클래스가 공유할 공통 상태를
나타냅니다.

```java
abstract class Animal {
    protected String name; // 모든 동물은 이름을 가진다.

    public Animal(String name) {
        this.name = name;
    }

    abstract void makeSound(); // 하위 클래스에서 구현할 메서드
}
```

#### 결론

따라서 추상 클래스에 변수를 포함시키는 것은 타입 검사기에게 제공하는 정보의 일부로 볼 수 있으며, 이는 객체 지향 설계에서 클래스가 어떻게 상태(필드)와 행동(메서드)을 모두 포함할 수 있는지를 반영합니다. 추상
클래스에 필드를 포함시키는 것은 해당 필드가 추상 클래스와 그 하위 클래스가 공유하는 공통 상태를 정의하기 때문에 오히려 유용할 수 있습니다. 이러한 공통 상태는 하위 클래스의 구체적인 구현에 영향을 미칠 수
있으며, 이는 타입 검사기가 타입의 안정성을 보장하는 데 필요한 정보를 포함한다고 볼 수 있습니다.

타입검사기의 관점으로는 위의 내용이고, 우리가 생각하는 객체 지향 설계에서의 내용은 또 별도로 있는 것

## 집합론적 타입

각 타입은 수학의 집합론에서 나오는 전체 집합, 공집합, 합집합, 교집합으로부터 유래되었다.  
다만 집합론을 조금이라도 안다면 전체 집합, 공집합, 합집합, 교집합을 떠올림으로써 각 타입을 이해하는데 도움을 받을 수 있을 것이다.

### 최대 타입

최대타입은 '가장 큰'타입이다.   
모든 값을 포함하는 타입이다.  
어느 값이든 최대 타입에 속한다.  
따라서 모든 타입은 최대 타입의 서브타입이라는 것이다.

'문자열은 값이다'가 사실이므로 String은 최대 타입의 서브타입이고, '사람 객체는 값이다'가 사실이므로 Person도 최대 타입의 서브타입인 셈이다.  
다시 말해 최대 타입은 모든 타입의 슈퍼타입이다.

| 프로그래밍 언어   | 슈퍼타입      | 설명                                                    |
|------------|-----------|-------------------------------------------------------|
| Java       | `Object`  | 모든 클래스의 최상위 슈퍼클래스입니다. 모든 객체는 이 타입으로부터 파생됩니다.          |
| C#         | `object`  | 모든 타입의 최상위 슈퍼타입입니다. 값 타입과 참조 타입 모두 이 타입에서 파생됩니다.      |
| TypeScript | `unknown` | 모든 타입의 슈퍼타입으로, `any` 보다 타입 안전성이 강화된 타입입니다.            |
| Scala      | `Any`     | 모든 타입의 슈퍼타입으로, `AnyVal`(값 타입)과 `AnyRef`(참조 타입)로 나뉩니다. |
| Kotlin     | `Any`     | 모든 참조 타입의 최상위 슈퍼타입입니다. 원시 타입은 포함하지 않습니다.              |
| Python     | `object`  | 모든 클래스와 타입의 최상위 슈퍼클래스입니다.                             |
| JavaScript | `Object`  | JavaScript에서 모든 객체의 최상위 슈퍼타입입니다. 함수도 이에 속합니다.         |

### 최소 타입

예외(exception)는 개발자가 throw(일부 언어에서는 raise)를 통해 의도적으로 발생시킬 수 있는 오류다.
일반적으로 예외로 인한 종료는 타입 오류로 분류하지 않는다. 다시 말해 타입 검사를 통과한 프로그램이더라도 예외가 발생해 실행이 갑작스럽게 중단될 수 있다.

```
??? error(String msg) {
    print(msg);
    throw Exception() 
}
```

```
??? assertNonzero(Int num) {
    return (num !=0) ? num : error(...);
}
```

두 가지 코드를 확인할 경우 우리는 에러가 무슨 타입을 반환해야 하는지 알 수 있다.

```
Int error(String msg) {
    print(msg);
    throw Exception() 
}
```

assert문이 여러 타입 형태로 정의될 경우는 어떻게 될까?  
error는 각 타입에 맞게 계속 생성되어야 한다.  
결국 error함수는 어디서든 호출되어야 하는 점이다.

error를 어디서든 호출할 수 있는 이유는 error가 계산이 끝나지 않는 함수이기 때문이다.  
error를 호출하면 값을 반환하지 못한 채 예외가 발생해 실행이 종료된다. error가 반환한 값이 사용될 자리가 어디든 상관 없는 것이다.

'계산을 끝마치지 못한다'를 표현할 수 있는 타입만 있으면 된다. 그 타입이 바로 최소 타입이다.
최소 타입은 어떤 값도 속하지 않는 타입이다.

최대 타입과 최소 타입은 정반대 개념이면서도 비슷한 면이 있다. 최대 타입이 '아무 값이나 될 수 있다'를 의미한다면 최소 타입은 '아무 곳에나 사용될 수 있다'를 의미한다.

| 프로그래밍 언어   | 최소 타입               | 설명                                                               |
|------------|---------------------|------------------------------------------------------------------|
| Java       | `void`              | 메서드가 아무런 값을 반환하지 않을 때 사용됩니다. 객체로는 사용할 수 없습니다.                    |
| C#         | `void`              | 메서드가 값을 반환하지 않을 때 사용합니다. 객체 타입으로는 `null`을 사용할 수 있습니다.            |
| TypeScript | `never`             | 도달할 수 없는 코드 영역을 표현할 때 사용됩니다. 예를 들어, 항상 예외를 던지는 함수 등에 사용됩니다.      |
| Scala      | `Nothing`           | 모든 타입의 하위 타입으로, 절대 인스턴스화될 수 없습니다. 비정상적 종료나 비반환 함수에 사용됩니다.        |
| Kotlin     | `Nothing`           | 프로그램 흐름이 정상적으로 종료되지 않을 때 사용됩니다. 예를 들어, 예외를 던지는 함수 등에 사용됩니다.      |
| Python     | N/A                 | Python은 명시적인 '최소 타입' 개념이 없습니다. 하지만, `None` 타입이 유사한 역할을 할 수 있습니다. |
| JavaScript | `undefined`, `null` | 명시적인 최소 타입은 없으나, `undefined`와 `null`이 비슷한 역할을 합니다.               |

## 이거나 타입

함수가 받는 인자 타입이 여러가지가 되어야 하는 경우가 생긴다.  
이거나 타입은 두개의 타입으로부터 만들어진다. 타입 A와 B로 만든 이거나 타입은 A|B라 쓰며 직관적으로 'A이거나 B'를 나타낸다. 즉, 어떤 값이 A에 속하면 A|B에 속하고, B에 속하면 A|B에 속한다.  
다시 말해 A이거나 B이면 A|B인 것이다. 그래서 이거나 타입으로 부른다.

이거나 타입을 제공하는 언어는 위치에 민감한 타입검사라는 정교한 방식의 타입 검사를 사용한다.  
변수의 값을 읽는 부품의 타입 검사를 할 때 해당 변수가 정의된 곳의 타입 표시만 보는 것이 아니라, 그 변수가 어디서 사용되는지도 고려하는 것이다.

## 이면서 타입

이면서 타입은 다중 상속(multiple inheritance)를 다룰 때 유용하다.
A & B 라고 쓰며 'A 이면서 B'를 나타낸다. 젊잖게 말하면 교집합 타입이라 할 수 있다.

## 함수와 서브타입

여러 언어에서 함수를 값으로 사용할 수 있다. 함수를 값으로 사용한다는 말은 함수를 변수에 저장하거나 다른 함수에 인자로 전달하거나 다른 함수에서 반환한다는 뜻이다.
이렇게 값으로 사용되는 함수를 일급함수(first-class function)라고 부른다.

A가 B의 서브타입일 때 C => A 가 C => B의 서브타입이다. (공변)
A가 B의 서브타입일 때 B => C 가 A => C의 서브타입이다. (반공변)

# 매개변수에 의한 다형성

## 제네릭 함수

매개변수에 의한 다형성(parametric polymorphism)은 타입 매개변수를 통해 다형성으로 만드는 기능으로, 제네릭스(generics)라고 부른다.

## 제네릭 메서드

제네릭 함수를 정의하고 사용하는 것과 비슷하게 제네릭 메서드(generic method)를 정의하고 사용할 수 있다.  
제네릭 메서드는 클래스 안에 정의된다는 점만 제외하면 제네릭 함수와 똑같다.

## 타입 인자 추론

타입 인자 추론은 타입 추론의 일종으로, 제네릭 함수나 제네릭 메서드를 호출할 때 개발자가 타입 인자를 생략할 수 있도록 하는 기능이다.

## 힌들리-밀너 타입 추론

일부 언어에서는 제네릭 함수를 정의할 때조차 타입 추론을 한다. 이런 타입 추론을 힌들리-밀너 타입추론(Hindley-Milner type inference) 라고 부른다.

---


힌들리-밀너 타입 추론(Hindley-Milner type inference)은 프로그래밍 언어에서 변수와 표현식의 타입을 자동으로 결정하는 알고리즘입니다. 이 시스템은 처음에 로직학자 J. Roger
Hindley가 발견하고, 후에 로빈 Milner가 ML 프로그래밍 언어에 적용하여 유명해졌습니다. 데이몬드 L. Damas가 이 알고리즘에 기여한 것도 중요하며, 때로는 HM(D) 타입 시스템이라고도 불립니다.  
힌들리-밀너 타입 추론의 핵심은 프로그래머가 타입 선언을 명시적으로 제공하지 않아도, 프로그램의 타입 정보를 자동으로 추론하고 검사할 수 있다는 점입니다.  
이 시스템은 다음과 같은 특징을 가집니다:

* 타입 안전성: 프로그램이 실행되기 전에 타입 오류를 발견할 수 있어, 런타임 오류의 가능성을 줄입니다.
* 타입 유추: 변수나 함수의 타입을 코드의 사용 패턴을 통해 자동으로 결정합니다.
* 다형성 지원: 파라미터 다형성을 지원하여, 동일한 함수를 여러 타입의 인자에 적용할 수 있습니다.

예를 들어, Haskell이나 OCaml 같은 함수형 프로그래밍 언어에서는 힌들리-밀너 타입 추론 시스템을 사용하여, 프로그래머가 타입을 명시적으로 선언하지 않아도 프로그램의 타입을 결정할 수 있습니다. 이로 인해
코드가 더 간결해지고, 프로그래머가 타입에 대해 고민하는 시간이 줄어듭니다.

---
(어떤 사람들은 힌들리-밀너 타입 추론 대신 렛 다형성(let polymorphism) 이라는 용어를 사용하는데, 이는 힌들리-밀너 타입 추론을 사용하는 대표적인 언어인 오캐멀에서 함수를 정의할 때 사용하는 let인
데서 온 것이다.)

힌들리-밀너 타입 추론의 강력함은 타입 추론이 대개 그렇듯이 개발자에게 양날의 검이다. 함수를 정의할 때 함수를 제네릭 타입으로 만들어야 하는지 고민이 없기 때문에, 함수 기능만 집중한 채 몸통만 열심히 작성하면
된다.  
하지만, 어떤 함수가 자동으로 제네릭 함수가 되었다는 사실을 개발자가 눈치채지 못한다면 문제가 생길 수 있다.  
따라서, 힌들리-밀너 타입 추론을 제공하는 언어를 사용할 때는 우선 매개변수 타입 표시 없이 코드를 작성하다가 이해하기 어려운 오류 메시지가 나오면 함수에 매개변수 타입을 추가해 보는 게 좋다.

## 제네릭 타입

타입에 타입 매개변수를 추가하면 제네릭 타입(generic type)이 된다. 프로그래밍을 하는데 꼭 필요한 기본적인 타입조차도 제네릭 타입으로 표현될 정도로 제네릭 타입은 유용하다.

## 제네릭 클래스

개발자가 자신만의 제네릭 타입을 직접 정의하고 싶은 경우도 있다. 이런 이유로 대부분의 언어는 새로운 제네릭 타입을 정의할 수 있는 기능도 제공한다. 이 기능이 제네릭 클래스(generic class)다.

제네릭 클래스는 타입 매개변수를 가진 클래스다. 정의할 때 제네릭 함수와 비슷하게 타입 매개변수를 명시해야 하고, 사용할 때는 제네릭 타입으로 리스트나 맵과 비슷한 방식으로 사용된다.

## 무엇이든 타입

무엇이든 타입(universally quantified type)과 무엇인가 타입(existentially quantified type)은 매개변수에 의한 다형성의 심화 과정이라 부를 만한 개념이다.  
어떤 사람들은 무엇이든 타입을 '보편 양화 타입'이라 번역한다.

```
T randUniform<T>(List<T> lst) { ... }
```

ranUniform은 아무 리스트를 하나 인자로 받아 거기서 무작위로 값을 하나 선택해 반환한다. 각 원소가 선택될 확률은 모두 똑같다.  
예를 들어 원소가 3개인 리스트가 주어진 경우 각 원소가 1/3 확률로 선택된다.
함수를 대략적으로 작성해보자

```
Void simulate() {
    ...
    Int number = randUniform(List<Int>(30, 35, 40, 45));
    ...
    String sepcies = randUniform(List<String>("Gazelle", "Lion", "Zebra"));
    ...
}
```

여기서 새로운 무작위 함수를 정의하자.

```
Void simulate(??? rand) {
    ...
    Int number = rand(List<Int>(30, 35, 40, 45));
    ...
    String sepcies = rand(List<String>("Gazelle", "Lion", "Zebra"));
    ...
}

simulate(randUniform);
simulate(randGeometric);
```

여기서 문제는 딱 하나다. simulate 매개변수 rand가 무슨 타입을 가져가야 할까? List<Int> => Int는 불가능하다.

simulate를 제네릭 함수로 만들면 해결될까?

```
Void simulate<T>(List<T> => T rand) {
    ...
    Int number = rand(List<Int>(30, 35, 40, 45));
    ...
    String sepcies = rand(List<String>("Gazelle", "Lion", "Zebra"));
    ...
}
```

해결되지 않는다. 이 함수는 List<Int> => Int 타입의 함수도 인자로 받을 수 있고 List<String> => String 타입의 인자도 받을 수 있는 함수다.  
다음과 같이 쓸 수 있다는 말이다.

```
Int randInt(List<Int> lst) {...}
simulate<Int>(randInt);
String randString(List<String> lst) { ... }
simulate<String>(randString);
```

이런 난관을 해결해 줄 수 있는 기능이 무엇이든 타입이다. 무엇이든 타입을 사용하면 다음과 같이 코드를 작성할 수 있다.

```
Void simulate(forall T.(List<T> => T) rand) {
    ...
    Int number = rand(List<Int>(30, 35, 40, 45));
    ...
    String sepcies = rand(List<String>("Gazelle", "Lion", "Zebra"));
    ...
}

simulate(randUniform);
simulate(randGeometric);
```

forall T.A 형태(T는 타입 매개변수, A는 타입)로 생긴 타입을 무엇이든 타입이라 부른다.  
의미는 rand의 타입이 List<Int> => Int도 될 수 있고, List<String> => String도 될 수 있음을 뜻하는 타입인 것이다.

*무엇이든 타입을 제네릭 함수의 타입이라고 이해할 수 있다.*

```
def simulate(rand: [T] => List[T] => T): Unit = 
    val number:Int = rand[Int](List[Int](1,2))
    val species: String = rand[String](List[String]("a", "b"))
    ...
```

`def simulate(rand: [T] => List[T] => T)`를 좀 해석해보자면 simulate는 모든 타입에 대해 `List[T]를 입력 받고 T`를 리턴한다.

## 무엇인가 타입

무엇인가 타입은 '존재 양화 타입' 이라고 번역할 수 있다.

```
class Timestamper {
    Int init() { return 0; }
    Int next(Int t) { return t + 1};
    Bool cmp(Int t1, Int t2) { return t1 < t2; }
}

exists. T.{ T init(); T next(T t); Bool cmp(T t1, T T2); } create() {
    return Timestamper();
}
```

exists T.A 형태 (T는 타입 매개변수, A는 타입)로 생긴 타입이 무엇인가 타입니다. 이 타입은 create가 반환하는 값의 타입이 { T init(); T next(T t); Bool cmp(T t1, T
t2); }다' 가 사실이 되도록 만드는 T가 무엇인가 존재한다는 사실만 알려 줄 뿐이다.  
그래서 이 타입을 무엇인가 타입이라 부른다.

